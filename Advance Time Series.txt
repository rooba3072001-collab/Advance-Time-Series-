# ============================================================
# Advanced Multivariate Time Series Forecasting
# Transformer vs LSTM vs SARIMAX
# ============================================================

import numpy as np
import pandas as pd
import tensorflow as tf
from tensorflow.keras import layers, models
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_absolute_error, mean_squared_error
from statsmodels.tsa.statespace.sarimax import SARIMAX
import warnings
warnings.filterwarnings("ignore")

# =====================
# Reproducibility
# =====================
np.random.seed(42)
tf.random.set_seed(42)

# =====================
# 1. Synthetic Multivariate Dataset
# =====================
def generate_data(n_steps=1500):
    t = np.arange(n_steps)
    energy = 0.05*t + 10*np.sin(2*np.pi*t/24) + np.random.normal(0, 1, n_steps)
    temp = 20 + 5*np.sin(2*np.pi*t/365) + np.random.normal(0, 0.5, n_steps)
    humidity = 60 + 10*np.sin(2*np.pi*t/168) + np.random.normal(0, 2, n_steps)
    return pd.DataFrame({
        "energy": energy,
        "temperature": temp,
        "humidity": humidity
    })

data = generate_data()

# =====================
# 2. Scaling
# =====================
scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(data)

# =====================
# 3. Sequence Generator
# =====================
def create_sequences(data, window=48):
    X, y = [], []
    for i in range(len(data) - window):
        X.append(data[i:i+window])
        y.append(data[i+window, 0])
    return np.array(X), np.array(y)

WINDOW = 48
X, y = create_sequences(scaled_data, WINDOW)

split = int(0.8 * len(X))
X_train, X_test = X[:split], X[split:]
y_train, y_test = y[:split], y[split:]

# =====================
# 4. LSTM Baseline
# =====================
lstm_model = models.Sequential([
    layers.LSTM(64, return_sequences=True, input_shape=(WINDOW, 3)),
    layers.LSTM(32),
    layers.Dense(1)
])

lstm_model.compile(
    optimizer="adam",
    loss="mse"
)

lstm_model.fit(X_train, y_train, epochs=15, batch_size=32, verbose=0)
lstm_pred = lstm_model.predict(X_test).flatten()

# =====================
# 5. Transformer Model
# =====================
class TransformerBlock(layers.Layer):
    def __init__(self, embed_dim, num_heads, ff_dim):
        super().__init__()
        self.att = layers.MultiHeadAttention(num_heads=num_heads, key_dim=embed_dim)
        self.ffn = models.Sequential([
            layers.Dense(ff_dim, activation="relu"),
            layers.Dense(embed_dim)
        ])
        self.norm1 = layers.LayerNormalization()
        self.norm2 = layers.LayerNormalization()

    def call(self, inputs):
        attn_output = self.att(inputs, inputs)
        out1 = self.norm1(inputs + attn_output)
        ffn_output = self.ffn(out1)
        return self.norm2(out1 + ffn_output)

inputs = layers.Input(shape=(WINDOW, 3))
x = layers.Dense(64)(inputs)
x = TransformerBlock(64, 4, 128)(x)
x = layers.GlobalAveragePooling1D()(x)
outputs = layers.Dense(1)(x)

transformer = models.Model(inputs, outputs)
transformer.compile(optimizer="adam", loss="mse")

transformer.fit(X_train, y_train, epochs=20, batch_size=32, verbose=0)
transformer_pred = transformer.predict(X_test).flatten()

# =====================
# 6. SARIMAX
# =====================
sarimax = SARIMAX(
    data["energy"][:split],
    order=(2,1,2),
    seasonal_order=(1,1,1,24)
).fit(disp=False)

sarimax_pred = sarimax.forecast(len(y_test))

# =====================
# 7. Evaluation Metrics
# =====================
def metrics(y_true, y_pred):
    rmse = np.sqrt(mean_squared_error(y_true, y_pred))
    mae = mean_absolute_error(y_true, y_pred)
    mape = np.mean(np.abs((y_true - y_pred) / y_true)) * 100
    return rmse, mae, mape

lstm_m = metrics(y_test, lstm_pred)
trans_m = metrics(y_test, transformer_pred)
sar_m = metrics(y_test, sarimax_pred)

# =====================
# 8. Results
# =====================
results = pd.DataFrame({
    "Model": ["LSTM", "Transformer", "SARIMAX"],
    "RMSE": [lstm_m[0], trans_m[0], sar_m[0]],
    "MAE": [lstm_m[1], trans_m[1], sar_m[1]],
    "MAPE (%)": [lstm_m[2], trans_m[2], sar_m[2]]
})

print("\n=== Model Comparison ===")
print(results)
